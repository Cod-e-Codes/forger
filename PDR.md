# Project Design Report (PDR): Forger – Terminal Developer Toolkit

## Overview

**Forger** is a high-performance, terminal-native developer toolkit that integrates Cody’s most powerful CLI tools into a cohesive, extensible TUI system. Built for speed, clarity, and modularity, Forger allows developers to interact with codebases, snapshots, analysis results, local tooling, and chat logs—all from a unified, keyboard-driven dashboard.

Forger is designed to be a developer's cockpit: fast, focused, and extensible. It is not an IDE or GUI wrapper. It is a structured and performant terminal-native interface built around Cody’s ecosystem of command-line tools.

---

## Goals

- **Unified Developer UX**: Combine `marchat`, `ignoregrets`, `CodeSleuth`, `ascii-colorizer`, and optionally `parsec` into one discoverable and efficient dashboard.
- **Plugin Architecture**: Each tool is a plugin conforming to a common interface (`Init`, `Run`, `Render`, `HandleMsg`).
- **Terminal-First UX**: Built with Bubble Tea and Lip Gloss. No graphical abstraction layers or GUI frameworks.
- **Performance-Oriented**: All operations are fast and local. No implicit network use. Tools operate on IRs and file snapshots efficiently.
- **Extensibility**: Developers can extend Forger by adding plugins via configuration (`forger.toml`, `~/.config/forger/plugins/`, etc).
- **Snapshot Context**: Tools like `ignoregrets` and `CodeSleuth` operate within a shared snapshot context for accurate analysis and restoration.
- **Minimal Visual Overhead**: Visual output is expressive but minimalist—leveraging color, diagrams (e.g., Mermaid), and inline formatting over complex UI widgets.
- **Composability**: Plugins can interoperate through shared contexts such as snapshots, IRs, or workspace state.

---

## Non-Goals

- Forger is **not** a full-fledged IDE.
- It does **not** support collaborative cloud editing or real-time multiuser features.
- It does **not** provide GUI or web-based fallback views.
- It does **not** implement language servers or autocomplete engines internally.
- It does **not** duplicate GitHub/GitLab functionality—it complements local Git workflows.

---

## Modules & Responsibilities

| Module         | Description                                                                 |
|----------------|-----------------------------------------------------------------------------|
| `core/`        | Manages shared runtime, plugin lifecycle, user config, and workspace state. |
| `plugins/`     | Houses all tool integrations (`marchat`, `ignoregrets`, `CodeSleuth`, etc). |
| `ui/`          | Reusable Bubble Tea components (menus, status bar, graphs, overlays).       |
| `snapshots/`   | Snapshot manager built atop `ignoregrets`. Plugins can tag or consume data. |
| `parser/`      | Static analysis backend using CodeSleuth IR. Exposes clean API for plugins. |
| `chat/`        | TUI overlay interface for `marchat`. Supports terminal chat, logs, alerts.   |
| `colorizer/`   | GPU-accelerated `ascii-colorizer` output viewer for terminal-based diagrams. |

---

## Technical Constraints

- Written in Go using Bubble Tea, Lip Gloss, and standard library.
- Plugin interfaces must implement a defined contract: `Init`, `Run`, `Render`, `HandleMsg`.
- Configuration via `forger.toml` and standard XDG-compliant paths.
- Minimal external dependencies. Favor maintainability and performance.
- Plugins must fail gracefully and work independently.
- Uses a consistent message/event system across plugins.

---

## Example Plugin Interactions

- `ignoregrets` exposes a snapshot viewer that integrates with the workspace panel, allowing snapshot previews before branch switches.
- `CodeSleuth` renders COBOL IRs using Mermaid and visually highlights anomalies.
- `marchat` provides real-time repo-synced chat as an overlay panel, toggleable with keybindings.
- `ascii-colorizer` renders diagrams and code artifacts generated by other tools directly in the terminal.
- `parsec` (optional) formats structured logs, test output, or machine-readable CLI output into readable views.

---

## MVP Requirements

- Core runtime and plugin loader.
- Configurable layout: main workspace panel, sidebar, footer, overlays.
- Plugin APIs and lifecycle management.
- Integrated snapshot viewer from `ignoregrets`.
- CodeSleuth-based IR visualizer with Mermaid support.
- `marchat` overlay panel for terminal chat.
- `ascii-colorizer` viewer for diagrams and inline graph rendering.

---

## Future Features

- Plugin registry (e.g. `forger install plugin-name`)
- Git-aware workspace awareness (e.g. detect repo root, branch, changes)
- Command logging and output capture per plugin
- Configurable dashboards (via `.forger/config.toml`)
- Built-in fuzzy finder for commands, snapshots, or file search
- Custom TUI-based command launcher

# System Prompt for Forger Implementation

You are a senior software engineer implementing **Forger**, a terminal-native TUI developer toolkit. Forger integrates Cody’s CLI tools—including `marchat`, `ignoregrets`, `CodeSleuth`, `ascii-colorizer`, and optionally `parsec`—into a high-performance, modular dashboard.

Each tool functions as a plugin. Plugins conform to a standard Go interface and operate within a shared runtime environment powered by Bubble Tea and Lip Gloss. Forger is designed for power users and CLI developers who prefer structured, discoverable tooling in the terminal.

## Your Responsibilities

- Architect a clean plugin system with strict interfaces: `Init`, `Run`, `Render`, `HandleMsg`.
- Implement plugins as modular Go packages under `plugins/`, each providing their own views and interactions.
- Create reusable UI components (menus, panels, overlays, graphs) under `ui/`.
- Enable inter-plugin communication via shared snapshot or IR context (e.g. `ignoregrets` and `CodeSleuth`).
- Build an integrated snapshot viewer and manager using `ignoregrets` core logic.
- Provide an IR visualizer using `CodeSleuth`, rendering Mermaid diagrams and control flows.
- Render chat and logs in a non-intrusive panel using `marchat`, with keyboard toggles.
- Allow `ascii-colorizer` to display syntax-colored output, ASTs, diagrams, or plugin views.
- Ensure fast startup, high responsiveness, minimal memory usage.
- Write clean, idiomatic, testable Go code.
- Ensure user onboarding is seamless: clear configuration files, plugin discovery, help panel.

## Design Priorities

- Performance: Fast local execution, no bloat, zero implicit network traffic.
- Composability: Plugins work standalone and together.
- Extensibility: Easy to add or remove plugins without affecting core.
- Visual clarity: Minimalist, color-rich terminal UI with semantic layouts.
- UX consistency: All views and interactions follow shared design language.

## Scope Limitations

Forger is **not** an IDE, GUI, collaborative editor, or full code intelligence engine. It is a composable, local-first CLI developer dashboard built to unify and extend powerful terminal tools.

Your job is to make Forger elegant, discoverable, and powerful—without compromising the terminal-native experience.